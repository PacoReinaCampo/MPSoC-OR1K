\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\PassOptionsToPackage{hyphens}{url} % url is loaded by hyperref
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdftitle={Multi-Processor System on Chip with OR1K},
            pdfauthor={QueenField},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage[left=3cm,right=2cm,top=3cm,bottom=2cm]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\usepackage{longtable,booktabs}
% Fix footnotes in tables (requires footnote package)
\IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{long table}}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother


\title{Multi-Processor System on Chip with OR1K}
\author{QueenField}
\date{}

\begin{document}
\maketitle

\section{1. INTRODUCTION}\label{introduction}

\subsection{1.1. OPEN SOURCE PHILOSOPHY}\label{open-source-philosophy}

\textbf{For Windows Users!}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Settings → Apps → Apps \& features → Related settings, Programs and
  Features → Turn Windows features on or off → Windows Subsystem for
  Linux
\item
  Microsoft Store → INSTALL UBUNTU
\end{enumerate}

type:

\begin{verbatim}
sudo apt update
sudo apt upgrade
\end{verbatim}

\subsubsection{1.2.1. Open Source Hardware}\label{open-source-hardware}

\paragraph{1.2.1.1. MSP430 Processing
Unit}\label{msp430-processing-unit}

\paragraph{1.2.1.2. OpenRISC Processing
Unit}\label{openrisc-processing-unit}

\paragraph{1.2.1.3. RISC-V Processing
Unit}\label{risc-v-processing-unit}

\subsubsection{1.2.2. Open Source Software}\label{open-source-software}

\paragraph{1.2.2.1. MSP430 GNU Compiler
Collection}\label{msp430-gnu-compiler-collection}

\paragraph{1.2.2.2. OpenRISC GNU Compiler
Collection}\label{openrisc-gnu-compiler-collection}

\paragraph{1.2.2.3. RISC-V GNU Compiler
Collection}\label{risc-v-gnu-compiler-collection}

\subsection{1.2. RISC-V ISA}\label{risc-v-isa}

\subsubsection{1.2.1. ISA Bases}\label{isa-bases}

\paragraph{1.2.2.1. RISC-V 32}\label{risc-v-32}

\paragraph{1.2.2.2. RISC-V 64}\label{risc-v-64}

\paragraph{1.2.2.3. RISC-V 128}\label{risc-v-128}

\subsubsection{1.2.2. ISA Extensions}\label{isa-extensions}

\subsubsection{1.2.3. ISA Modes}\label{isa-modes}

\paragraph{1.2.3.1. RISC-V User}\label{risc-v-user}

\paragraph{1.2.3.2. RISC-V Supervisor}\label{risc-v-supervisor}

\paragraph{1.2.3.3. RISC-V Hypervisor}\label{risc-v-hypervisor}

\paragraph{1.2.3.4. RISC-V Machine}\label{risc-v-machine}

\section{2. PROJECTS}\label{projects}

\subsection{2.1. CORE-OR1K}\label{core-or1k}

\subsubsection{2.1.1. Functionality}\label{functionality}

\paragraph{2.1.1.1. Organization}\label{organization}

The CORE-OR1K is based on the Harvard architecture, which is a computer
architecture with separate storage and signal pathways for instructions
and data. The implementation is heavily modular, with each particular
functional block of the design being contained within its own HDL module
or modules. The OR1K implementation was developed in order to provide a
better platform for processor component development than previous
implementations.

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.29\columnwidth}\raggedright\strut
Core\strut
\end{minipage} & \begin{minipage}[b]{0.65\columnwidth}\raggedright\strut
Module description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.29\columnwidth}\raggedright\strut
\texttt{or1k\_core}\strut
\end{minipage} & \begin{minipage}[t]{0.65\columnwidth}\raggedright\strut
Top-level, instantiatng bus interfaces, data cache and CPU\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.29\columnwidth}\raggedright\strut
\texttt{...or1k\_dcache}\strut
\end{minipage} & \begin{minipage}[t]{0.65\columnwidth}\raggedright\strut
Data cache implementation\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.29\columnwidth}\raggedright\strut
\texttt{...or1k\_bus\_if\_xx}\strut
\end{minipage} & \begin{minipage}[t]{0.65\columnwidth}\raggedright\strut
Bus interface, depending on desired bus standard\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.29\columnwidth}\raggedright\strut
\texttt{...or1k\_cpu}\strut
\end{minipage} & \begin{minipage}[t]{0.65\columnwidth}\raggedright\strut
Pipeline implementation wrapper\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.29\columnwidth}\raggedright\strut
\texttt{.....or1k\_cpu\_xx}\strut
\end{minipage} & \begin{minipage}[t]{0.65\columnwidth}\raggedright\strut
Pipeline implementation, depending on configuration\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.29\columnwidth}\raggedright\strut
\texttt{.......or1k\_fetch\_xx}\strut
\end{minipage} & \begin{minipage}[t]{0.65\columnwidth}\raggedright\strut
Pipeline-implementation-dependent fetch stage\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.29\columnwidth}\raggedright\strut
\texttt{.......or1k\_decode}\strut
\end{minipage} & \begin{minipage}[t]{0.65\columnwidth}\raggedright\strut
Generic decode stage\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.29\columnwidth}\raggedright\strut
\texttt{.......or1k\_execute\_alu}\strut
\end{minipage} & \begin{minipage}[t]{0.65\columnwidth}\raggedright\strut
Generic ALU for execute stage\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.29\columnwidth}\raggedright\strut
\texttt{.......or1k\_lsu\_xx}\strut
\end{minipage} & \begin{minipage}[t]{0.65\columnwidth}\raggedright\strut
Pipeline-implementation-dependent load/store unit\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.29\columnwidth}\raggedright\strut
\texttt{.......or1k\_wb\_mux\_xx}\strut
\end{minipage} & \begin{minipage}[t]{0.65\columnwidth}\raggedright\strut
Pipeline-implementation-dependent writeback stage mux\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.29\columnwidth}\raggedright\strut
\texttt{.......or1k\_rf\_xx}\strut
\end{minipage} & \begin{minipage}[t]{0.65\columnwidth}\raggedright\strut
Pipeline-implementation-dependent register file\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.29\columnwidth}\raggedright\strut
\texttt{.......or1k\_ctrl\_xx}\strut
\end{minipage} & \begin{minipage}[t]{0.65\columnwidth}\raggedright\strut
Pipeline-implementation-dependent control stage\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

In a Harvard architecture, there is no need to make the two memories
share characteristics. In particular, the word width, timing,
implementation technology, and memory address structure can differ. In
some systems, instructions for pre-programmed tasks can be stored in
read-only memory while data memory generally requires read-write memory.
In some systems, there is much more instruction memory than data memory
so instruction addresses are wider than data addresses.

\paragraph{2.1.1.2. Pipeline}\label{pipeline}

In computer science, instruction pipelining is a technique for
implementing instruction-level parallelism within a PU. Pipelining
attempts to keep every part of the processor busy with some instruction
by dividing incoming instructions into a series of sequential steps
performed by different PUs with different parts of instructions
processed in parallel. It allows faster PU throughput than would
otherwise be possible at a given clock rate.

\begin{longtable}[]{@{}lll@{}}
\toprule
Typical & Modified & Module\tabularnewline
\midrule
\endhead
FETCH & FETCH & \texttt{or1k\_cache\_lru}\tabularnewline
& & \texttt{or1k\_fetch\_cappuccino}\tabularnewline
& & \texttt{or1k\_icache}\tabularnewline
& & \texttt{or1k\_immu}\tabularnewline
DECODE & DECODE & \texttt{or1k\_decode}\tabularnewline
EXECUTE \& CONTROL & EXECUTE \& WRITE-BACK &
\texttt{or1k\_execute\_alu}\tabularnewline
& & \texttt{or1k\_execute\_ctrl\_cappuccino}\tabularnewline
& & \texttt{or1k\_rf\_cappuccino}\tabularnewline
& & \texttt{or1k\_wb\_mux\_cappuccino}\tabularnewline
MEMORY & MEMORY & \texttt{or1k\_dcache}\tabularnewline
& & \texttt{or1k\_dmmu}\tabularnewline
& & \texttt{or1k\_lsu\_cappuccino}\tabularnewline
& & \texttt{or1k\_store\_buffer}\tabularnewline
WRITE-BACK & CONTROL & \texttt{or1k\_cfgrs}\tabularnewline
& & \texttt{or1k\_ctrl\_cappuccino}\tabularnewline
& & \texttt{or1k\_pcu}\tabularnewline
& & \texttt{or1k\_pic}\tabularnewline
& & \texttt{or1k\_ticktimer}\tabularnewline
\bottomrule
\end{longtable}

\begin{itemize}
\item
  IF -- Instruction Fetch Unit : Send out the PC and fetch the
  instruction from memory into the Instruction Register (IR); increment
  the PC to address the next sequential instruction. The IR is used to
  hold the next instruction that will be needed on subsequent clock
  cycles; likewise the register NPC is used to hold the next sequential
  PC.
\item
  ID -- Instruction Decode Unit : Decode the instruction and access the
  register file to read the registers. This unit gets instruction from
  IF, and extracts opcode and operand from that instruction. It also
  retrieves register values if requested by the operation.
\item
  EX -- Execution Unit : The ALU operates on the operands prepared in
  prior cycle, performing one functions depending on instruction type.
\item
  MEM -- Memory Access Unit : Instructions active in this unit are
  loads, stores and branches.
\item
  WB -- WriteBack Unit : Write the result into the register file,
  whether it comes from the memory system or from the ALU.
\end{itemize}

\subsubsection{2.1.2. Interface}\label{interface}

\paragraph{2.1.2.1. Constants}\label{constants}

\subparagraph{2.1.1.2.1. Basic Constants}\label{basic-constants}

\begin{longtable}[]{@{}llcc@{}}
\toprule
Parameter & Description & Default & Values\tabularnewline
\midrule
\endhead
OPTION\_OPERAND\_WIDTH & CPU data and address widths & 32 & 32,
64\tabularnewline
OPTION\_CPU0 & CPU pipeline core & \texttt{CAPPUCCINO} &
\texttt{CAPPUCCINO}\tabularnewline
OPTION\_RESET\_PC & Program Counter upon reset & \texttt{0x100} &
N\tabularnewline
\bottomrule
\end{longtable}

\subparagraph{2.1.1.2.2. Caching Constants}\label{caching-constants}

\begin{longtable}[]{@{}llcc@{}}
\toprule
Parameter & Description & Default & Values\tabularnewline
\midrule
\endhead
FEATURE\_DATACACHE & Enable memory access data caching & \texttt{NONE} &
\texttt{ENABLED}\tabularnewline
OPTION\_DCACHE\_BLOCK\_WIDTH & Address width of a cache block & 5 &
\texttt{n}\tabularnewline
OPTION\_DCACHE\_SET\_WIDTH & Set address width & 9 &
\texttt{n}\tabularnewline
OPTION\_DCACHE\_WAYS & Number of blocks per set & 2 &
\texttt{n}\tabularnewline
OPTION\_DCACHE\_LIMIT\_WIDTH & Maximum address width & 32 &
\texttt{n}\tabularnewline
OPTION\_DCACHE\_SNOOP & Bus snooping for cache coherency & \texttt{NONE}
& \texttt{ENABLED}\tabularnewline
FEATURE\_INSTRUCTIONCACHE & Memory access instruction caching &
\texttt{NONE} & \texttt{ENABLED}\tabularnewline
OPTION\_ICACHE\_BLOCK\_WIDTH & Address width of a cache block & 5 &
\texttt{n}\tabularnewline
OPTION\_ICACHE\_SET\_WIDTH & Set address width & 9 &
\texttt{n}\tabularnewline
OPTION\_ICACHE\_WAYS & Number of blocks per set & 2 &
\texttt{n}\tabularnewline
OPTION\_ICACHE\_LIMIT\_WIDTH & Maximum address width & 32 &
\texttt{n}\tabularnewline
\bottomrule
\end{longtable}

\subparagraph{2.1.1.2.3. Memory Management Unit (MMU)
Constants}\label{memory-management-unit-mmu-constants}

\begin{longtable}[]{@{}llcc@{}}
\toprule
Parameter & Description & Default & Values\tabularnewline
\midrule
\endhead
FEATURE\_DMMU & Enable the data bus MMU & \texttt{NONE} &
\texttt{ENABLED}\tabularnewline
FEATURE\_DMMU\_HW\_TLB\_RELOAD & Enable hardware TLB reload &
\texttt{NONE} & \texttt{ENABLED}\tabularnewline
OPTION\_DMMU\_SET\_WIDTH & Set address width & 6 &
\texttt{n}\tabularnewline
OPTION\_DMMU\_WAYS & Number of ways per set & 1 &
\texttt{n}\tabularnewline
FEATURE\_IMMU & Enable the instruction bus MMU & \texttt{NONE} &
\texttt{ENABLED}\tabularnewline
FEATURE\_IMMU\_HW\_TLB\_RELOAD & Enable hardware TLB reload &
\texttt{NONE} & \texttt{ENABLED}\tabularnewline
OPTION\_IMMU\_SET\_WIDTH & Set address width & 6 &
\texttt{n}\tabularnewline
OPTION\_IMMU\_WAYS & Number of ways per set & 1 &
\texttt{n}\tabularnewline
\bottomrule
\end{longtable}

\subparagraph{2.1.1.2.4. System Bus
Constants}\label{system-bus-constants}

\begin{longtable}[]{@{}llc@{}}
\toprule
Parameter & Description & Default\tabularnewline
\midrule
\endhead
FEATURE\_STORE\_BUFFER & Load store unit store buffer &
\texttt{ENABLED}\tabularnewline
OPTION\_STORE\_BUFFER\_DEPTH\_WIDTH & Load store unit store buffer depth
& 8\tabularnewline
BUS\_IF\_TYPE & Bus interface type & \texttt{WISHBONE32}\tabularnewline
IBUS\_WB\_TYPE & Instruction bus interface &
\texttt{B3\_READ\_BURSTING}\tabularnewline
DBUS\_WB\_TYPE & Data bus interface type option &
\texttt{CLASSIC}\tabularnewline
\bottomrule
\end{longtable}

\subparagraph{2.1.1.2.5. Hardware Unit Configuration
Constants}\label{hardware-unit-configuration-constants}

\begin{longtable}[]{@{}llc@{}}
\toprule
Parameter & Description & Default\tabularnewline
\midrule
\endhead
FEATURE\_TRACEPORT\_EXEC & Traceport hardware interface &
\texttt{NONE}\tabularnewline
FEATURE\_DEBUGUNIT & Hardware breakpoints and debug unit &
\texttt{NONE}\tabularnewline
FEATURE\_PERFCOUNTERS & Performance counters unit &
\texttt{NONE}\tabularnewline
OPTION\_PERFCOUNTERS\_NUM & Performance counters to generate &
0\tabularnewline
FEATURE\_TIMER & Internal OpenRISC timer &
\texttt{ENABLED}\tabularnewline
FEATURE\_PIC & Internal OpenRISC PIC & \texttt{ENABLED}\tabularnewline
OPTION\_PIC\_TRIGGER & PIC trigger mode & \texttt{LEVEL}\tabularnewline
OPTION\_PIC\_NMI\_WIDTH & Non maskable interrupts width &
0\tabularnewline
OPTION\_RF\_CLEAR\_ON\_INIT & clearing all registers on initialization &
0\tabularnewline
OPTION\_RF\_NUM\_SHADOW\_GPR & Number of shadow register files &
0\tabularnewline
OPTION\_RF\_ADDR\_WIDTH & Address width of the register file &
5\tabularnewline
OPTION\_RF\_WORDS & Number of registers in the register file &
32\tabularnewline
FEATURE\_FASTCONTEXTS & Fast context switching of register sets &
\texttt{NONE}\tabularnewline
FEATURE\_MULTICORE & \texttt{coreid} and \texttt{numcores} SPR registers
& \texttt{NONE}\tabularnewline
FEATURE\_FPU & FPU, for cappuccino pipeline only &
\texttt{NONE}\tabularnewline
OPTION\_FTOI\_ROUNDING & Rounding behavior for \texttt{lf.ftoi.s} &
\texttt{CPP}\tabularnewline
FEATURE\_BRANCH\_PREDICTOR & Branch predictor implementation &
\texttt{SIMPLE}\tabularnewline
\bottomrule
\end{longtable}

\subparagraph{2.1.1.2.6. Exception Handling
Options}\label{exception-handling-options}

\begin{longtable}[]{@{}llc@{}}
\toprule
Parameter & Description & Default\tabularnewline
\midrule
\endhead
FEATURE\_DSX & Enable setting the \texttt{SR{[}DSX{]}} flag &
\texttt{ENABLED}\tabularnewline
FEATURE\_RANGE & Enable checking and raising range exceptions &
\texttt{ENABLED}\tabularnewline
FEATURE\_OVERFLOW & Enable checking and raising overflow exceptions &
\texttt{ENABLED}\tabularnewline
\bottomrule
\end{longtable}

\subparagraph{2.1.1.2.7. ALU Configuration
Options}\label{alu-configuration-options}

\begin{longtable}[]{@{}llc@{}}
\toprule
Parameter & Description & Default\tabularnewline
\midrule
\endhead
FEATURE\_MULTIPLIER & Specify the multiplier implementation &
\texttt{THREESTAGE}\tabularnewline
FEATURE\_DIVIDER & Specify the divider implementation &
\texttt{SERIAL}\tabularnewline
OPTION\_SHIFTER & Specify the shifter implementation &
\texttt{BARREL}\tabularnewline
FEATURE\_CARRY\_FLAG & Enable checking and setting the carry flag &
\texttt{ENABLED}\tabularnewline
\bottomrule
\end{longtable}

\subparagraph{2.1.1.2.8. Instruction Enabling
Options}\label{instruction-enabling-options}

\begin{longtable}[]{@{}llc@{}}
\toprule
Parameter & Description & Default\tabularnewline
\midrule
\endhead
FEATURE\_MAC & \texttt{l.mac*} multiply accumulate instructions &
\texttt{NONE}\tabularnewline
FEATURE\_SYSCALL & \texttt{l.sys} OS syscall instruction &
\texttt{ENABLED}\tabularnewline
FEATURE\_TRAP & \texttt{l.trap} instruction &
\texttt{ENABLED}\tabularnewline
FEATURE\_ADDC & \texttt{l.addc} add with \texttt{carry} flag instruction
& \texttt{ENABLED}\tabularnewline
FEATURE\_SRA & \texttt{l.sra} shirt right arithmetic instruction &
\texttt{ENABLED}\tabularnewline
FEATURE\_ROR & \texttt{l.ror*} rotate right instructions &
\texttt{NONE}\tabularnewline
FEATURE\_EXT & \texttt{l.ext*} sign extend instructions &
\texttt{NONE}\tabularnewline
FEATURE\_CMOV & \texttt{l.cmov} conditional move instruction &
\texttt{ENABLED}\tabularnewline
FEATURE\_FFL1 & \texttt{l.f{[}fl{]}1} find first/last set bit
instructions & \texttt{ENABLED}\tabularnewline
FEATURE\_ATOMIC & \texttt{l.lwa} and \texttt{l.swa} atomic instructions
& \texttt{ENABLED}\tabularnewline
FEATURE\_CUST1 & \texttt{l.cust*} custom instruction &
\texttt{NONE}\tabularnewline
FEATURE\_CUST2 & \texttt{l.cust*} custom instruction &
\texttt{NONE}\tabularnewline
FEATURE\_CUST3 & \texttt{l.cust*} custom instruction &
\texttt{NONE}\tabularnewline
FEATURE\_CUST4 & \texttt{l.cust*} custom instruction &
\texttt{NONE}\tabularnewline
FEATURE\_CUST5 & \texttt{l.cust*} custom instruction &
\texttt{NONE}\tabularnewline
FEATURE\_CUST6 & \texttt{l.cust*} custom instruction &
\texttt{NONE}\tabularnewline
FEATURE\_CUST7 & \texttt{l.cust*} custom instruction &
\texttt{NONE}\tabularnewline
FEATURE\_CUST8 & \texttt{l.cust*} custom instruction &
\texttt{NONE}\tabularnewline
\bottomrule
\end{longtable}

\paragraph{2.1.2.2. Signals}\label{signals}

\subparagraph{2.1.2.2.1. Instruction Inputs/Outputs
Bus}\label{instruction-inputsoutputs-bus}

\subparagraph{2.1.2.2.2. Data Inputs/Outputs
Bus}\label{data-inputsoutputs-bus}

\subsubsection{2.1.3. Registers}\label{registers}

\subsubsection{2.1.4. Interruptions}\label{interruptions}

\subsection{2.2. PU-OR1K}\label{pu-or1k}

\subsubsection{2.2.1. Processing Unit}\label{processing-unit}

The OpenRISC implementation has a 32/64 bit Microarchitecture, 5 stages
data pipeline and an Instruction Set Architecture based on Reduced
Instruction Set Computer. Compatible with Wishbone Bus. Only For
Researching.

\begin{longtable}[]{@{}ll@{}}
\toprule
Processing Unit & Module description\tabularnewline
\midrule
\endhead
\texttt{or1k\_pu} & Processing Unit\tabularnewline
\texttt{...or1k\_core} & Core\tabularnewline
\texttt{...mpsoc\_msi\_wb\_interface} & Master Slave
Interface\tabularnewline
\texttt{...tap\_top} & Test Access Port\tabularnewline
\texttt{...adbg\_top} & Debugger on Chip\tabularnewline
\texttt{...mpsoc\_wb\_spram} & Single-Port RAM for Instruction \&
Data\tabularnewline
\texttt{...mpsoc\_wb\_uart} & Universal Asynchronous
Receiver-Transmitter\tabularnewline
\bottomrule
\end{longtable}

A PU cache is a hardware cache used by the PU to reduce the average cost
(time or energy) to access instruction/data from the main memory. A
cache is a smaller, faster memory, closer to a core, which stores copies
of the data from frequently used main memory locations. Most CPUs have
different independent caches, including instruction and data caches.

\subsubsection{2.2.2. Instruction Cache}\label{instruction-cache}

\paragraph{2.2.2.1. Functionality}\label{functionality-1}

\begin{longtable}[]{@{}ll@{}}
\toprule
Instruction Memory & Module description\tabularnewline
\midrule
\endhead
\texttt{riscv\_imem\_ctrl} & Instruction Memory Access
Block\tabularnewline
\texttt{...riscv\_membuf} & Memory Access Buffer\tabularnewline
\texttt{.....riscv\_ram\_queue} & Fall-through Queue\tabularnewline
\texttt{...riscv\_memmisaligned} & Misalignment Check\tabularnewline
\texttt{...riscv\_mmu} & Memory Management Unit\tabularnewline
\texttt{...riscv\_pmachk} & Physical Memory Attributes
Checker\tabularnewline
\texttt{...riscv\_pmpchk} & Physical Memory Protection
Checker\tabularnewline
\texttt{...riscv\_icache\_core} & Instruction Cache (Write
Back)\tabularnewline
\texttt{.....riscv\_ram\_1rw} & RAM 1RW\tabularnewline
\texttt{.......riscv\_ram\_1rw\_generic} & RAM 1RW
Generic\tabularnewline
\texttt{...riscv\_dext} & Data External Access Logic\tabularnewline
\texttt{...riscv\_ram\_queue} & Fall-through Queue\tabularnewline
\texttt{...riscv\_mux} & Bus-Interface-Unit Mux\tabularnewline
\texttt{riscv\_biu} & Bus Interface Unit\tabularnewline
\bottomrule
\end{longtable}

\paragraph{2.2.2.2. Interface}\label{interface-1}

\subparagraph{2.2.2.2.1. Instruction INPUTS/OUTPUTS AMBA4 AXI-Lite
Bus}\label{instruction-inputsoutputs-amba4-axi-lite-bus}

2.2.2.2.1.1. Signals of the Read and Write Address channels

\begin{longtable}[]{@{}llccl@{}}
\toprule
Write Port & Read Port & Size & Direction & Description\tabularnewline
\midrule
\endhead
\texttt{AWID} & \texttt{ARID} & \texttt{AXI\_ID\_WIDTH} & Output &
Address ID, to identify multiple streams\tabularnewline
\texttt{AWADDR} & \texttt{ARADDR} & \texttt{AXI\_ADDR\_WIDTH} & Output &
Address of the first beat of the burst\tabularnewline
\texttt{AWLEN} & \texttt{ARLEN} & 8 & Output & Number of beats inside
the burst\tabularnewline
\texttt{AWSIZE} & \texttt{ARSIZE} & 3 & Output & Size of each
beat\tabularnewline
\texttt{AWBURST} & \texttt{ARBURST} & 2 & Output & Type of the
burst\tabularnewline
\texttt{AWLOCK} & \texttt{ARLOCK} & 1 & Output & Lock type, to provide
atomic operations\tabularnewline
\texttt{AWCACHE} & \texttt{ARCACHE} & 4 & Output & Memory type, progress
through the system\tabularnewline
\texttt{AWPROT} & \texttt{ARPROT} & 3 & Output & Protection
type\tabularnewline
\texttt{AWQOS} & \texttt{ARQOS} & 4 & Output & Quality of Service of the
transaction\tabularnewline
\texttt{AWREGION} & \texttt{ARREGION} & 4 & Output & Region identifier,
physical to logical\tabularnewline
\texttt{AWUSER} & \texttt{ARUSER} & \texttt{AXI\_USER\_WIDTH} & Output &
User-defined data\tabularnewline
\texttt{AWVALID} & \texttt{ARVALID} & 1 & Output & xVALID handshake
signal\tabularnewline
\texttt{AWREADY} & \texttt{ARREADY} & 1 & Input & xREADY handshake
signal\tabularnewline
\bottomrule
\end{longtable}

2.2.2.2.1.2. Signals of the Read and Write Data channels

\begin{longtable}[]{@{}llccl@{}}
\toprule
Write Port & Read Port & Size & Direction & Description\tabularnewline
\midrule
\endhead
\texttt{WID} & \texttt{RID} & \texttt{AXI\_ID\_WIDTH} & Output & Data
ID, to identify multiple streams\tabularnewline
\texttt{WDATA} & \texttt{RDATA} & \texttt{AXI\_DATA\_WIDTH} & Output &
Read/Write data\tabularnewline
\texttt{-\/-} & \texttt{RRESP} & 2 & Output & Read response, current
RDATA status\tabularnewline
\texttt{WSTRB} & \texttt{-\/-} & \texttt{AXI\_STRB\_WIDTH} & Output &
Byte strobe, WDATA signal\tabularnewline
\texttt{WLAST} & \texttt{RLAST} & 1 & Output & Last beat
identifier\tabularnewline
\texttt{WUSER} & \texttt{RUSER} & \texttt{AXI\_USER\_WIDTH} & Output &
User-defined data\tabularnewline
\texttt{WVALID} & \texttt{RVALID} & 1 & Output & xVALID handshake
signal\tabularnewline
\texttt{WREADY} & \texttt{RREADY} & 1 & Input & xREADY handshake
signal\tabularnewline
\bottomrule
\end{longtable}

2.2.2.2.1.3. Signals of the Write Response channel

\begin{longtable}[]{@{}lccl@{}}
\toprule
Write Port & Size & Direction & Description\tabularnewline
\midrule
\endhead
\texttt{BID} & \texttt{AXI\_ID\_WIDTH} & Input & Write response ID, to
identify multiple streams\tabularnewline
\texttt{BRESP} & 2 & Input & Write response, to specify the burst
status\tabularnewline
\texttt{BUSER} & \texttt{AXI\_USER\_WIDTH} & Input & User-defined
data\tabularnewline
\texttt{BVALID} & 1 & Input & xVALID handshake signal\tabularnewline
\texttt{BREADY} & 1 & Output & xREADY handshake signal\tabularnewline
\bottomrule
\end{longtable}

\subparagraph{2.2.2.2.2. Instruction INPUTS/OUTPUTS AMBA3 AHB-Lite
Bus}\label{instruction-inputsoutputs-amba3-ahb-lite-bus}

\begin{longtable}[]{@{}lccl@{}}
\toprule
Port & Size & Direction & Description\tabularnewline
\midrule
\endhead
\texttt{HRESETn} & 1 & Input & Asynchronous Active Low
Reset\tabularnewline
\texttt{HCLK} & 1 & Input & System Clock Input\tabularnewline
& & &\tabularnewline
\texttt{IHSEL} & 1 & Output & Instruction Bus Select\tabularnewline
\texttt{IHADDR} & \texttt{PLEN} & Output & Instruction Address
Bus\tabularnewline
\texttt{IHRDATA} & \texttt{XLEN} & Input & Instruction Read Data
Bus\tabularnewline
\texttt{IHWDATA} & \texttt{XLEN} & Output & Instruction Write Data
Bus\tabularnewline
\texttt{IHWRITE} & 1 & Output & Instruction Write Select\tabularnewline
\texttt{IHSIZE} & 3 & Output & Instruction Transfer Size\tabularnewline
\texttt{IHBURST} & 3 & Output & Instruction Transfer Burst
Size\tabularnewline
\texttt{IHPROT} & 4 & Output & Instruction Transfer Protection
Level\tabularnewline
\texttt{IHTRANS} & 2 & Output & Instruction Transfer Type\tabularnewline
\texttt{IHMASTLOCK} & 1 & Output & Instruction Transfer Master
Lock\tabularnewline
\texttt{IHREADY} & 1 & Input & Instruction Slave Ready
Indicator\tabularnewline
\texttt{IHRESP} & 1 & Input & Instruction Transfer
Response\tabularnewline
\bottomrule
\end{longtable}

\subparagraph{2.2.2.2.3. Instruction INPUTS/OUTPUTS Wishbone
Bus}\label{instruction-inputsoutputs-wishbone-bus}

\begin{longtable}[]{@{}lccl@{}}
\toprule
Port & Size & Direction & Description\tabularnewline
\midrule
\endhead
\texttt{rst} & 1 & Input & Synchronous Active High Reset\tabularnewline
\texttt{clk} & 1 & Input & System Clock Input\tabularnewline
& & &\tabularnewline
\texttt{iadr} & \texttt{AW} & Input & Instruction Address
Bus\tabularnewline
\texttt{idati} & \texttt{DW} & Input & Instruction Input
Bus\tabularnewline
\texttt{idato} & \texttt{DW} & Output & Instruction Output
Bus\tabularnewline
\texttt{isel} & \texttt{DW/8} & Input & Byte Select
Signals\tabularnewline
\texttt{iwe} & 1 & Input & Write Enable Input\tabularnewline
\texttt{istb} & 1 & Input & Strobe Signal/Core Select
Input\tabularnewline
\texttt{icyc} & 1 & Input & Valid Bus Cycle Input\tabularnewline
\texttt{iack} & 1 & Output & Bus Cycle Acknowledge Output\tabularnewline
\texttt{ierr} & 1 & Output & Bus Cycle Error Output\tabularnewline
\texttt{iint} & 1 & Output & Interrupt Signal Output\tabularnewline
\bottomrule
\end{longtable}

\subsubsection{2.2.3. Data Cache}\label{data-cache}

\paragraph{2.2.3.1. Functionality}\label{functionality-2}

\begin{longtable}[]{@{}ll@{}}
\toprule
Data Memory & Module description\tabularnewline
\midrule
\endhead
\texttt{riscv\_dmem\_ctrl} & Data Memory Access Block\tabularnewline
\texttt{...riscv\_membuf} & Memory Access Buffer\tabularnewline
\texttt{.....riscv\_ram\_queue} & Fall-through Queue\tabularnewline
\texttt{...riscv\_memmisaligned} & Misalignment Check\tabularnewline
\texttt{...riscv\_mmu} & Memory Management Unit\tabularnewline
\texttt{...riscv\_pmachk} & Physical Memory Attributes
Checker\tabularnewline
\texttt{...riscv\_pmpchk} & Physical Memory Protection
Checker\tabularnewline
\texttt{...riscv\_dcache\_core} & Data Cache (Write Back)\tabularnewline
\texttt{.....riscv\_ram\_1rw} & RAM 1RW\tabularnewline
\texttt{.......riscv\_ram\_1rw\_generic} & RAM 1RW
Generic\tabularnewline
\texttt{...riscv\_dext} & Data External Access Logic\tabularnewline
\texttt{...riscv\_mux} & Bus-Interface-Unit Mux\tabularnewline
\texttt{riscv\_biu} & Bus Interface Unit\tabularnewline
\bottomrule
\end{longtable}

\paragraph{2.2.3.2. Interface}\label{interface-2}

\subparagraph{2.2.3.2.1. Data INPUTS/OUTPUTS AMBA4 AXI-Lite
Bus}\label{data-inputsoutputs-amba4-axi-lite-bus}

2.2.3.2.1.1. Signals of the Read and Write Address channels

\begin{longtable}[]{@{}llccl@{}}
\toprule
Write Port & Read Port & Size & Direction & Description\tabularnewline
\midrule
\endhead
\texttt{AWID} & \texttt{ARID} & \texttt{AXI\_ID\_WIDTH} & Output &
Address ID, to identify multiple streams\tabularnewline
\texttt{AWADDR} & \texttt{ARADDR} & \texttt{AXI\_ADDR\_WIDTH} & Output &
Address of the first beat of the burst\tabularnewline
\texttt{AWLEN} & \texttt{ARLEN} & 8 & Output & Number of beats inside
the burst\tabularnewline
\texttt{AWSIZE} & \texttt{ARSIZE} & 3 & Output & Size of each
beat\tabularnewline
\texttt{AWBURST} & \texttt{ARBURST} & 2 & Output & Type of the
burst\tabularnewline
\texttt{AWLOCK} & \texttt{ARLOCK} & 1 & Output & Lock type, to provide
atomic operations\tabularnewline
\texttt{AWCACHE} & \texttt{ARCACHE} & 4 & Output & Memory type, progress
through the system\tabularnewline
\texttt{AWPROT} & \texttt{ARPROT} & 3 & Output & Protection
type\tabularnewline
\texttt{AWQOS} & \texttt{ARQOS} & 4 & Output & Quality of Service of the
transaction\tabularnewline
\texttt{AWREGION} & \texttt{ARREGION} & 4 & Output & Region identifier,
physical to logical\tabularnewline
\texttt{AWUSER} & \texttt{ARUSER} & \texttt{AXI\_USER\_WIDTH} & Output &
User-defined data\tabularnewline
\texttt{AWVALID} & \texttt{ARVALID} & 1 & Output & xVALID handshake
signal\tabularnewline
\texttt{AWREADY} & \texttt{ARREADY} & 1 & Input & xREADY handshake
signal\tabularnewline
\bottomrule
\end{longtable}

2.2.3.2.1.2. Signals of the Read and Write Data channels

\begin{longtable}[]{@{}llccl@{}}
\toprule
Write Port & Read Port & Size & Direction & Description\tabularnewline
\midrule
\endhead
\texttt{WID} & \texttt{RID} & \texttt{AXI\_ID\_WIDTH} & Output & Data
ID, to identify multiple streams\tabularnewline
\texttt{WDATA} & \texttt{RDATA} & \texttt{AXI\_DATA\_WIDTH} & Output &
Read/Write data\tabularnewline
\texttt{-\/-} & \texttt{RRESP} & 2 & Output & Read response, current
RDATA status\tabularnewline
\texttt{WSTRB} & \texttt{-\/-} & \texttt{AXI\_STRB\_WIDTH} & Output &
Byte strobe, WDATA signal\tabularnewline
\texttt{WLAST} & \texttt{RLAST} & 1 & Output & Last beat
identifier\tabularnewline
\texttt{WUSER} & \texttt{RUSER} & \texttt{AXI\_USER\_WIDTH} & Output &
User-defined data\tabularnewline
\texttt{WVALID} & \texttt{RVALID} & 1 & Output & xVALID handshake
signal\tabularnewline
\texttt{WREADY} & \texttt{RREADY} & 1 & Input & xREADY handshake
signal\tabularnewline
\bottomrule
\end{longtable}

2.2.3.2.1.3. Signals of the Write Response channel

\begin{longtable}[]{@{}lccl@{}}
\toprule
Write Port & Size & Direction & Description\tabularnewline
\midrule
\endhead
\texttt{BID} & \texttt{AXI\_ID\_WIDTH} & Input & Write response ID, to
identify multiple streams\tabularnewline
\texttt{BRESP} & 2 & Input & Write response, to specify the burst
status\tabularnewline
\texttt{BUSER} & \texttt{AXI\_USER\_WIDTH} & Input & User-defined
data\tabularnewline
\texttt{BVALID} & 1 & Input & xVALID handshake signal\tabularnewline
\texttt{BREADY} & 1 & Output & xREADY handshake signal\tabularnewline
\bottomrule
\end{longtable}

\paragraph{2.2.3.2.2. Data INPUTS/OUTPUTS AMBA3 AHB-Lite
Bus}\label{data-inputsoutputs-amba3-ahb-lite-bus}

\begin{longtable}[]{@{}lccl@{}}
\toprule
Port & Size & Direction & Description\tabularnewline
\midrule
\endhead
\texttt{HRESETn} & 1 & Input & Asynchronous Active Low
Reset\tabularnewline
\texttt{HCLK} & 1 & Input & System Clock Input\tabularnewline
& & &\tabularnewline
\texttt{DHSEL} & 1 & Output & Data Bus Select\tabularnewline
\texttt{DHADDR} & \texttt{PLEN} & Output & Data Address
Bus\tabularnewline
\texttt{DHRDATA} & \texttt{XLEN} & Input & Data Read Data
Bus\tabularnewline
\texttt{DHWDATA} & \texttt{XLEN} & Output & Data Write Data
Bus\tabularnewline
\texttt{DHWRITE} & 1 & Output & Data Write Select\tabularnewline
\texttt{DHSIZE} & 3 & Output & Data Transfer Size\tabularnewline
\texttt{DHBURST} & 3 & Output & Data Transfer Burst Size\tabularnewline
\texttt{DHPROT} & 4 & Output & Data Transfer Protection
Level\tabularnewline
\texttt{DHTRANS} & 2 & Output & Data Transfer Type\tabularnewline
\texttt{DHMASTLOCK} & 1 & Output & Data Transfer Master
Lock\tabularnewline
\texttt{DHREADY} & 1 & Input & Data Slave Ready Indicator\tabularnewline
\texttt{DHRESP} & 1 & Input & Data Transfer Response\tabularnewline
\bottomrule
\end{longtable}

\paragraph{2.2.3.2.3. Data INPUTS/OUTPUTS Wishbone
Bus}\label{data-inputsoutputs-wishbone-bus}

\begin{longtable}[]{@{}lccl@{}}
\toprule
Port & Size & Direction & Description\tabularnewline
\midrule
\endhead
\texttt{rst} & 1 & Input & Synchronous Active High Reset\tabularnewline
\texttt{clk} & 1 & Input & System Clock Input\tabularnewline
& & &\tabularnewline
\texttt{dadr} & \texttt{AW} & Input & Data Address Bus\tabularnewline
\texttt{ddati} & \texttt{DW} & Input & Data Input Bus\tabularnewline
\texttt{ddato} & \texttt{DW} & Output & Data Output Bus\tabularnewline
\texttt{dsel} & \texttt{DW/8} & Input & Byte Select
Signals\tabularnewline
\texttt{dwe} & 1 & Input & Write Enable Input\tabularnewline
\texttt{dstb} & 1 & Input & Strobe Signal/Core Select
Input\tabularnewline
\texttt{dcyc} & 1 & Input & Valid Bus Cycle Input\tabularnewline
\texttt{dack} & 1 & Output & Bus Cycle Acknowledge Output\tabularnewline
\texttt{derr} & 1 & Output & Bus Cycle Error Output\tabularnewline
\texttt{dint} & 1 & Output & Interrupt Signal Output\tabularnewline
\bottomrule
\end{longtable}

\subsection{2.3. SoC-OR1K}\label{soc-or1k}

\subsubsection{2.3.1. MPSoC-DBG}\label{mpsoc-dbg}

\subsubsection{2.3.2. MPSoC-DMA}\label{mpsoc-dma}

\subsubsection{2.3.3. MPSoC-GPIO}\label{mpsoc-gpio}

\subsubsection{2.3.4. MPSoC-MPI}\label{mpsoc-mpi}

\subsubsection{2.3.5. MPSoC-MPRAM}\label{mpsoc-mpram}

\subsubsection{2.3.6. MPSoC-MSI}\label{mpsoc-msi}

\subsubsection{2.3.7. MPSoC-NoC}\label{mpsoc-noc}

\subsubsection{2.3.8. MPSoC-SPRAM}\label{mpsoc-spram}

\subsubsection{2.3.9. MPSoC-UART}\label{mpsoc-uart}

\subsection{2.4. MPSoC-OR1K}\label{mpsoc-or1k}

\section{3. WORKFLOW}\label{workflow}

\subsection{3.1. HARDWARE}\label{hardware}

\textbf{1. System Level (SystemC/SystemVerilog)}

The System Level abstraction of a system only looks at its biggest
building blocks like processing units or peripheral devices. At this
level the circuit is usually described using traditional programming
languages like SystemC or SystemVerilog. Sometimes special software
libraries are used that are aimed at simulation circuits on the system
level. The IEEE 1685-2009 standard defines the IP-XACT file format that
can be used to represent designs on the system level and building blocks
that can be used in such system level designs.

\textbf{2. Behavioral \& Register Transfer Level (VHDL/Verilog)}

At the Behavioural Level abstraction a language aimed at hardware
description such as Verilog or VHDL is used to describe the circuit, but
so-called behavioural modeling is used in at least part of the circuit
description. In behavioural modeling there must be a language feature
that allows for imperative programming to be used to describe data paths
and registers. This is the always -block in Verilog and the process
-block in VHDL.

A design in Register Transfer Level representation is usually stored
using HDLs like Verilog and VHDL. But only a very limited subset of
features is used, namely minimalistic always blocks (Verilog) or process
blocks (VHDL) that model the register type used and unconditional
assignments for the datapath logic. The use of HDLs on this level
simplifies simulation as no additional tools are required to simulate a
design in Register Transfer Level representation.

\textbf{3. Logical Gate}

At the Logical Gate Level the design is represented by a netlist that
uses only cells from a small number of single-bit cells, such as basic
logic gates (AND, OR, NOT, XOR, etc.) and registers (usually D-Type
Flip-flops). A number of netlist formats exists that can be used on this
level such as the Electronic Design Interchange Format (EDIF), but for
ease of simulation often a HDL netlist is used. The latter is a HDL file
(Verilog or VHDL) that only uses the most basic language constructs for
instantiation and connecting of cells.

\textbf{4. Physical Gate}

On the Physical Gate Level only gates are used that are physically
available on the target architecture. In some cases this may only be
NAND, NOR and NOT gates as well as D-Type registers. In the case of an
FPGA-based design the Physical Gate Level representation is a netlist of
LUTs with optional output registers, as these are the basic building
blocks of FPGA logic cells.

\textbf{5. Switch Level}

A Switch Level representation of a circuit is a netlist utilizing single
transistors as cells. Switch Level modeling is possible in Verilog and
VHDL, but is seldom used in modern designs, as in modern digital ASIC or
FPGA flows the physical gates are considered the atomic build blocks of
the logic circuit.

\subsubsection{3.1.1. Front-End Open Source
Tools}\label{front-end-open-source-tools}

\paragraph{3.1.1.1. Modeling System Level of
Hardware}\label{modeling-system-level-of-hardware}

\emph{A System Description Language Editor is a computer tool allows to
generate software code. A System Description Language is a formal
language, which comprises a Programming Language (input), producing a
Hardware Description (output). Programming languages are used in
computer programming to implement algorithms. The description of a
programming language is split into the two components of syntax (form)
and semantics (meaning).}

\textbf{SystemVerilog System Description Language Editor}

type:

\begin{verbatim}
git clone --recursive https://github.com/emacs-mirror/emacs

cd emacs
./configure
make
sudo make install
\end{verbatim}

\paragraph{3.1.1.2. Simulating System Level of
Hardware}\label{simulating-system-level-of-hardware}

\emph{A System Description Language Simulator (translator) is a computer
program that translates computer code written in a Programming Language
(the source language) into a Hardware Description Language (the target
language). The compiler is primarily used for programs that translate
source code from a high-level programming language to a low-level
language to create an executable program.}

\textbf{SystemVerilog System Description Language Simulator}

type:

\begin{verbatim}
git clone --recursive http://git.veripool.org/git/verilator

cd verilator
autoconf
./configure
make
sudo make install
\end{verbatim}

\begin{verbatim}
cd sim/verilog/tests/wb/verilator
source SIMULATE-IT
\end{verbatim}

\begin{verbatim}
cd sim/verilog/tests/ahb3/verilator
source SIMULATE-IT
\end{verbatim}

\begin{verbatim}
cd sim/verilog/tests/axi4/verilator
source SIMULATE-IT
\end{verbatim}

\paragraph{3.1.1.3. Verifying System Level of
Hardware}\label{verifying-system-level-of-hardware}

\emph{A UVM standard improves interoperability and reduces the cost of
repurchasing and rewriting IP for each new project or Electronic Design
Automation tool. It also makes it easier to reuse verification
components. The UVM Class Library provides generic utilities, such as
component hierarchy, Transaction Library Model or configuration
database, which enable the user to create virtually any structure wanted
for the testbench.}

\textbf{SystemVerilog System Description Language Verifier}

type:

\begin{verbatim}
git clone --recursive https://github.com/QueenField/UVM
\end{verbatim}

\begin{verbatim}
cd sim/verilog/pu/or1k/wb/msim
source SIMULATE-IT
\end{verbatim}

\begin{verbatim}
cd sim/verilog/pu/or1k/ahb3/msim
source SIMULATE-IT
\end{verbatim}

\begin{verbatim}
cd sim/verilog/pu/or1k/axi4/msim
source SIMULATE-IT
\end{verbatim}

\paragraph{3.1.1.4. Describing Register Transfer Level of
Hardware}\label{describing-register-transfer-level-of-hardware}

\emph{A Hardware Description Language Editor is any editor that allows
to generate hardware code. Hardware Description Language is a
specialized computer language used to describe the structure and
behavior of digital logic circuits. It allows for the synthesis of a HDL
into a netlist, which can then be synthesized, placed and routed to
produce the set of masks used to create an integrated circuit.}

\textbf{VHDL/Verilog Hardware Description Language Editor}

type:

\begin{verbatim}
git clone --recursive https://github.com/emacs-mirror/emacs

cd emacs
./configure
make
sudo make install
\end{verbatim}

\paragraph{3.1.1.5. Simulating Register Transfer Level of
Hardware}\label{simulating-register-transfer-level-of-hardware}

\emph{A Hardware Description Language Simulator uses mathematical models
to replicate the behavior of an actual hardware device. Simulation
software allows for modeling of circuit operation and is an invaluable
analysis tool. Simulating a circuit's behavior before actually building
it can greatly improve design efficiency by making faulty designs known
as such, and providing insight into the behavior of electronics circuit
designs.}

\textbf{Verilog Hardware Description Language Simulator}

type:

\begin{verbatim}
git clone --recursive https://github.com/steveicarus/iverilog

cd iverilog
sh autoconf.sh
./configure
make
sudo make install
\end{verbatim}

\begin{verbatim}
cd sim/verilog/tests/wb/iverilog
source SIMULATE-IT
\end{verbatim}

\begin{verbatim}
cd sim/verilog/tests/ahb3/iverilog
source SIMULATE-IT
\end{verbatim}

\begin{verbatim}
cd sim/verilog/tests/axi4/iverilog
source SIMULATE-IT
\end{verbatim}

\textbf{VHDL Hardware Description Language Simulator}

type:

\begin{verbatim}
git clone --recursive https://github.com/ghdl/ghdl

cd ghdl
./configure --prefix=/usr/local
make
sudo make install
\end{verbatim}

\begin{verbatim}
cd sim/vhdl/tests/wb/ghdl
source SIMULATE-IT
\end{verbatim}

\begin{verbatim}
cd sim/vhdl/tests/ahb3/ghdl
source SIMULATE-IT
\end{verbatim}

\begin{verbatim}
cd sim/vhdl/tests/axi4/ghdl
source SIMULATE-IT
\end{verbatim}

\paragraph{3.1.1.6. Synthesizing Register Transfer Level of
Hardware}\label{synthesizing-register-transfer-level-of-hardware}

\emph{A Hardware Description Language Synthesizer turns a RTL
implementation into a Logical Gate Level implementation. Logical design
is a step in the standard design cycle in which the functional design of
an electronic circuit is converted into the representation which
captures logic operations, arithmetic operations, control flow, etc. In
EDA parts of the logical design is automated using synthesis tools based
on the behavioral description of the circuit.}

\textbf{Verilog Hardware Description Language Synthesizer}

type:

\begin{verbatim}
git clone --recursive https://github.com/YosysHQ/yosys

cd yosys
make
sudo make install
\end{verbatim}

\textbf{VHDL Hardware Description Language Synthesizer}

type:

\begin{verbatim}
git clone --recursive https://github.com/ghdl/ghdl-yosys-plugin
cd ghdl-yosys-plugin
make GHDL=/usr/local
sudo yosys-config --exec mkdir -p --datdir/plugins
sudo yosys-config --exec cp "ghdl.so" --datdir/plugins/ghdl.so
\end{verbatim}

\paragraph{3.1.1.7. Optimizing Register Transfer Level of
Hardware}\label{optimizing-register-transfer-level-of-hardware}

\emph{A Hardware Description Language Optimizer finds an equivalent
representation of the specified logic circuit under specified
constraints (minimum area, pre-specified delay). This tool combines
scalable logic optimization based on And-Inverter Graphs (AIGs),
optimal-delay DAG-based technology mapping for look-up tables and
standard cells, and innovative algorithms for sequential synthesis and
verification.}

\textbf{Verilog Hardware Description Language Optimizer}

type:

\begin{verbatim}
git clone --recursive https://github.com/YosysHQ/yosys

cd yosys
make
sudo make install
\end{verbatim}

\paragraph{3.1.1.8. Verifying Register Transfer Level of
Hardware}\label{verifying-register-transfer-level-of-hardware}

\emph{A Hardware Description Language Verifier proves or disproves the
correctness of intended algorithms underlying a hardware system with
respect to a certain formal specification or property, using formal
methods of mathematics. Formal verification uses modern techniques
(SAT/SMT solvers, BDDs, etc.) to prove correctness by essentially doing
an exhaustive search through the entire possible input space (formal
proof).}

\textbf{Verilog Hardware Description Language Verifier}

type:

\begin{verbatim}
git clone --recursive https://github.com/YosysHQ/SymbiYosys
\end{verbatim}

\subsubsection{3.1.2. Back-End Open Source
Tools}\label{back-end-open-source-tools}

\textbf{I. Back-End Workflow Qflow for ASICs}

type:

\begin{verbatim}
sudo apt install bison cmake flex freeglut3-dev libcairo2-dev libgsl-dev \
libncurses-dev libx11-dev m4 python-tk python3-tk swig tcl tcl-dev tk-dev tcsh
\end{verbatim}

type:

\begin{verbatim}
git clone --recursive https://github.com/RTimothyEdwards/qflow

cd qflow
./configure
make
sudo make install
\end{verbatim}

\paragraph{3.1.2.1. Planning Switch Level of
Hardware}\label{planning-switch-level-of-hardware}

\emph{A Floor-Planner of an Integrated Circuit (IC) is a schematic
representation of tentative placement of its major functional blocks. In
modern electronic design process floor-plans are created during the
floor-planning design stage, an early stage in the hierarchical approach
to Integrated Circuit design. Depending on the design methodology being
followed, the actual definition of a floor-plan may differ.}

\textbf{Floor-Planner}

type:

\begin{verbatim}
git clone --recursive https://github.com/RTimothyEdwards/magic

cd magic
./configure
make
sudo make install
\end{verbatim}

\paragraph{3.1.2.2. Placing Switch Level of
Hardware}\label{placing-switch-level-of-hardware}

\emph{A Standard Cell Placer takes a given synthesized circuit netlist
together with a technology library and produces a valid placement
layout. The layout is optimized according to the aforementioned
objectives and ready for cell resizing and buffering, a step essential
for timing and signal integrity satisfaction. Physical design flow are
iterated a number of times until design closure is achieved.}

\textbf{Standard Cell Placer}

type:

\begin{verbatim}
git clone --recursive https://github.com/rubund/graywolf

cd graywolf
mkdir build
cd build
cmake ..
make
sudo make install
\end{verbatim}

\paragraph{3.1.2.3. Timing Switch Level of
Hardware}\label{timing-switch-level-of-hardware}

\emph{A Standard Cell Timing-Analizer is a simulation method of
computing the expected timing of a digital circuit without requiring a
simulation of the full circuit. High-performance integrated circuits
have traditionally been characterized by the clock frequency at which
they operate. Measuring the ability of a circuit to operate at the
specified speed requires an ability to measure, during the design
process, its delay at numerous steps.}

\textbf{Standard Cell Timing-Analizer}

type:

\begin{verbatim}
git clone --recursive https://github.com/The-OpenROAD-Project/OpenSTA

cd OpenSTA
mkdir build
cd build
cmake ..
make
sudo make install
\end{verbatim}

\paragraph{3.1.2.4. Routing Switch Level of
Hardware}\label{routing-switch-level-of-hardware}

\emph{A Standard Cell Router takes pre-existing polygons consisting of
pins on cells, and pre-existing wiring called pre-routes. Each of these
polygons are associated with a net. The primary task of the router is to
create geometries such that all terminals assigned to the same net are
connected, no terminals assigned to different nets are connected, and
all design rules are obeyed.}

\textbf{Standard Cell Router}

type:

\begin{verbatim}
git clone --recursive https://github.com/RTimothyEdwards/qrouter

cd qrouter
./configure
make
sudo make install
\end{verbatim}

\paragraph{3.1.2.5. Simulating Switch Level of
Hardware}\label{simulating-switch-level-of-hardware}

\emph{A Standard Cell Simulator treats transistors as ideal switches.
Extracted capacitance and lumped resistance values are used to make the
switch a little bit more realistic than the ideal, using the RC time
constants to predict the relative timing of events. This simulator
represents a circuit in terms of its exact transistor structure but
describes the electrical behavior in a highly idealized way.}

\textbf{Standard Cell Simulator}

type:

\begin{verbatim}
git clone --recursive https://github.com/RTimothyEdwards/irsim

cd irsim
./configure
make
sudo make install
\end{verbatim}

\paragraph{3.1.2.6. Verifying Switch Level of Hardware
LVS}\label{verifying-switch-level-of-hardware-lvs}

\emph{A Standard Cell Verifier compares netlists, a process known as LVS
(Layout vs.~Schematic). This step ensures that the geometry that has
been laid out matches the expected circuit. The greatest need for LVS is
in large analog or mixed-signal circuits that cannot be simulated in
reasonable time. LVS can be done faster than simulation, and provides
feedback that makes it easier to find errors.}

\textbf{Standard Cell Verifier}

type:

\begin{verbatim}
git clone --recursive https://github.com/RTimothyEdwards/netgen

cd netgen
./configure
make
sudo make install
\end{verbatim}

\paragraph{3.1.2.7. Checking Switch Level of Hardware
DRC}\label{checking-switch-level-of-hardware-drc}

\emph{A Standard Cell Checker is a geometric constraint imposed on
Printed Circuit Board (PCB) and Integrated Circuit (IC) designers to
ensure their designs function properly, reliably, and can be produced
with acceptable yield. Design Rules for production are developed by
hardware engineers based on the capability of their processes to realize
design intent. Design Rule Checking (DRC) is used to ensure that
designers do not violate design rules.}

\textbf{Standard Cell Checker}

type:

\begin{verbatim}
git clone --recursive https://github.com/RTimothyEdwards/magic

cd magic
./configure
make
sudo make install
\end{verbatim}

\paragraph{3.1.2.8. Printing Switch Level of Hardware
GDS}\label{printing-switch-level-of-hardware-gds}

\emph{A Standard Cell Editor allows to print a set of standard cells.
The standard cell methodology is an abstraction, whereby a low-level
VLSI layout is encapsulated into a logical representation. A standard
cell is a group of transistor and interconnect structures that provides
a boolean logic function (AND, OR, XOR, XNOR, inverters) or a storage
function (flipflop or latch).}

\textbf{Standard Cell Editor}

type:

\begin{verbatim}
git clone --recursive https://github.com/RTimothyEdwards/magic

cd magic
./configure
make
sudo make install
\end{verbatim}

\textbf{II. Back-End Workflow Symbiflow for FPGAs}

\subsection{3.2. SOFTWARE}\label{software}

\subsubsection{3.2.1. Compilers}\label{compilers}

type:

\begin{verbatim}
sudo apt install git libgmp-dev libmpfr-dev libmpc-dev zlib1g-dev texinfo \
build-essential flex bison
\end{verbatim}

\paragraph{3.2.1.1. OpenRISC GNU C/C++}\label{openrisc-gnu-cc}

type:

\begin{verbatim}
git clone git://sourceware.org/git/binutils-gdb.git binutils
git clone https://github.com/openrisc/or1k-gcc.git gcc
git clone git://sourceware.org/git/newlib-cygwin.git newlib
git clone git://sourceware.org/git/binutils-gdb.git gdb

export PATH=/opt/or1k-elf-gcc/bin:${PATH}

mkdir build-binutils; cd build-binutils
../binutils/configure --target=or1k-elf --prefix=/opt/or1k-elf-gcc \
--disable-itcl --disable-tk --disable-tcl --disable-winsup --disable-gdbtk \
--disable-libgui --disable-rda --disable-sid --disable-sim --disable-gdb \
--with-sysroot --disable-newlib --disable-libgloss --with-system-zlib
make
sudo make install
cd ..

mkdir build-gcc-stage1; cd build-gcc-stage1
../gcc/configure --target=or1k-elf --prefix=/opt/or1k-elf-gcc \
--enable-languages=c --disable-shared --disable-libssp
make
sudo make install
cd ..

mkdir build-newlib; cd build-newlib
../newlib/configure --target=or1k-elf --prefix=/opt/or1k-elf-gcc
make
sudo make install
cd ..

mkdir build-gcc-stage2; cd build-gcc-stage2
../gcc/configure --target=or1k-elf --prefix=/opt/or1k-elf-gcc \
--enable-languages=c,c++ --disable-shared --disable-libssp --with-newlib
make
sudo make install
cd ..

mkdir build-gdb; cd build-gdb
../gdb/configure --target=or1k-elf --prefix=/opt/or1k-elf-gcc --disable-itcl \
--disable-tk --disable-tcl --disable-winsup --disable-gdbtk --disable-libgui \
--disable-rda --disable-sid --with-sysroot --disable-newlib --disable-libgloss \
--disable-gas --disable-ld --disable-binutils --disable-gprof --with-system-zlib
make
sudo make install
cd ..
\end{verbatim}

\paragraph{3.2.1.2. OpenRISC GNU Go}\label{openrisc-gnu-go}

type:

\begin{verbatim}
git clone --recursive https://go.googlesource.com/go riscv-go
cd riscv-go/src
./all.bash
cd ../..
sudo mv riscv-go /opt
\end{verbatim}

\subsubsection{3.2.2. Simulators}\label{simulators}

\paragraph{3.2.2.1. Or1ksim (For Hardware
Engineers)}\label{or1ksim-for-hardware-engineers}

type:

\begin{verbatim}
git clone --recursive https://github.com/openrisc/or1ksim

cd or1ksim
mkdir build
cd build
../configure --prefix=/opt/or1ksim --program-prefix=or1k-
make
sudo make install
\end{verbatim}

\paragraph{3.2.2.2. QEMU (For Software
Engineers)}\label{qemu-for-software-engineers}

type:

\begin{verbatim}
export PATH=/opt/or1k-elf-gcc/bin:${PATH}

git clone --recursive https://github.com/qemu/qemu

cd qemu
./configure --prefix=/opt/or1k-elf-gcc \
--target-list=or1k-softmmu,or1k-linux-user
make
sudo make install
\end{verbatim}

\section{4. CONCLUSION}\label{conclusion}

\subsection{4.1. HARDWARE}\label{hardware-1}

\begin{verbatim}
cd synthesis/yosys
source SYNTHESIZE-IT
\end{verbatim}

\subsubsection{4.1.1. GSCL 45 nm ASIC}\label{gscl-45-nm-asic}

type:

\begin{verbatim}
cd synthesis/qflow
source FLOW-IT
\end{verbatim}

\subsubsection{4.1.2. Lattice iCE40 FPGA}\label{lattice-ice40-fpga}

type:

\begin{verbatim}
cd synthesis/symbiflow
source FLOW-IT
\end{verbatim}

\subsection{4.2. SOFTWARE}\label{software-1}

\subsubsection{4.2.1. OpenRISC Tests}\label{openrisc-tests}

type:

\begin{verbatim}
export PATH=/opt/or1k-elf-gcc/bin:${PATH}

rm -rf tests
rm -rf or1k-tests

mkdir tests
mkdir tests/elf
mkdir tests/hex

git clone --recursive https://github.com/openrisc/or1k-tests

cd or1k-tests/native
make clean
make

cd build/or1k

source ../../../../elf2hex.sh

mv *.hex ../../../../tests/hex
mv or1k-* ../../../../tests/elf

cd ../..

make clean
\end{verbatim}

elf2hex.sh:

\begin{verbatim}
or1k-elf-objcopy -O ihex or1k-alignillegalinsn or1k-alignillegalinsn.hex
or1k-elf-objcopy -O ihex or1k-backtoback_jmp or1k-backtoback_jmp.hex
...
or1k-elf-objcopy -O ihex or1k-trapdelayslot or1k-trapdelayslot.hex
\end{verbatim}

type:

\begin{verbatim}
export PATH=/opt/or1ksim/bin:${PATH}

or1k-sim or1k-alignillegalinsn
or1k-sim or1k-backtoback_jmp
...
or1k-sim or1k-trapdelayslot
\end{verbatim}

\subsubsection{4.2.2. OpenRISC Bare Metal}\label{openrisc-bare-metal}

type:

\begin{verbatim}
rm -rf hello_c.elf
rm -rf hello_c.hex

export PATH=/opt/or1k-elf-gcc/bin:${PATH}

or1k-elf-gcc hello_c.c -o hello_c.elf
\end{verbatim}

C Language:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<stdio.h>}

\DataTypeTok{int}\NormalTok{ main() \{}
\NormalTok{  printf(}\StringTok{"Hello QueenField!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
  \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

type:

\begin{verbatim}
export PATH=/opt/or1ksim/bin:${PATH}

or1k-sim hello_c.elf
\end{verbatim}

type:

\begin{verbatim}
rm -rf hello_cpp.elf
rm -rf hello_cpp.hex

export PATH=/opt/or1k-elf-gcc/bin:${PATH}

or1k-elf-g++ hello_cpp.cpp -o hello_cpp.elf
\end{verbatim}

C++ Language:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<iostream>}

\DataTypeTok{int}\NormalTok{ main() \{}
  \BuiltInTok{std::}\NormalTok{cout << }\StringTok{"Hello QueenField!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{;}
  \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

type:

\begin{verbatim}
export PATH=/opt/or1ksim/bin:${PATH}

or1k-sim hello_cpp.elf
\end{verbatim}

\subsubsection{4.2.3. OpenRISC Operating
System}\label{openrisc-operating-system}

\paragraph{4.2.3.1. GNU Linux}\label{gnu-linux}

\textbf{Building Linux}

type:

\begin{verbatim}
export PATH=/opt/or1k-elf-gcc/bin:${PATH}

git clone --recursive https://github.com/torvalds/linux

cd linux
make ARCH=openrisc CROSS_COMPILE=or1k-linux- defconfig
make ARCH=openrisc CROSS_COMPILE=or1k-linux-

cp vmlinux ..
cd ..
rm -rf linux
\end{verbatim}

\textbf{Running Linux in a OpenRISC Core}

type:

\begin{verbatim}
export PATH=/opt/or1k-elf-gcc/bin:${PATH}

qemu-system-or1k -cpu or1200 -M or1k-sim -kernel vmlinux-core -serial stdio -nographic \
-monitor none
\end{verbatim}

\textbf{Running Linux in a OpenRISC Tile}

type:

\begin{verbatim}
export PATH=/opt/or1k-elf-gcc/bin:${PATH}

qemu-system-or1k -cpu or1200 -M or1k-sim -kernel vmlinux-tile -serial stdio \
-nographic -monitor none -smp cpus=2
\end{verbatim}

\paragraph{4.2.3.2. GNU Hurd}\label{gnu-hurd}

\subsubsection{4.2.4. OpenRISC
Distribution}\label{openrisc-distribution}

\paragraph{4.2.4.1. GNU Debian}\label{gnu-debian}

\paragraph{4.2.4.2. GNU Fedora}\label{gnu-fedora}

\end{document}
